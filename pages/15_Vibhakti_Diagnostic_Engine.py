import streamlit as st
import json
import os
import random
import pandas as pd
from collections import Counter

# --- рез. рдкреЗрдЬ рд╕реЗрдЯрдЕрдк ---
st.set_page_config(page_title="Vibhakti Diagnostic Engine", layout="wide", page_icon="ЁЯФм")


@st.cache_data
def load_shabd_data():
    # рдбреЙрдХреНрдЯрд░ рд╕рд╛рд╣рдм рджреНрд╡рд╛рд░рд╛ рдирд┐рд░реНрджреЗрд╢рд┐рдд рдкрд╛рде: data/shabdroop.json
    file_path = os.path.join("data", "shabdroop.json")
    try:
        if not os.path.exists(file_path): return []
        with open(file_path, "r", encoding="utf-8") as file:
            return json.load(file)
    except:
        return []


# --- реи. Robust Sanskrit-Aware Suffix Matcher ---
def sanskrit_match(word, suffix):
    """рд╕рдВрд╕реНрдХреГрдд рдХреЗ рдЕрджреГрд╢реНрдп 'рдЕ', рдорд╛рддреНрд░рд╛рдУрдВ рдФрд░ рд╡реНрдпрдЮреНрдЬрдирд╛рдиреНрдд рд▓реЛрдк рдХреЛ рдкрд╣рдЪрд╛рдирдиреЗ рд╡рд╛рд▓рд╛ рд▓реЙрдЬрд┐рдХ"""
    if not suffix or suffix == "--рд╕рднреА рджрд┐рдЦрд╛рдПрдВ--": return True
    word = word.strip()

    # рд╕реНрд╡рд░-рдорд╛рддреНрд░рд╛ рдореИрдкрд┐рдВрдЧ
    vowel_to_matra = {
        'рдЖ': 'рд╛', 'рдЗ': 'рд┐', 'рдИ': 'реА', 'рдЙ': 'реБ', 'рдК': 'реВ',
        'рдЛ': 'реГ', 'реа': 'реД', 'рдП': 'реЗ', 'рдР': 'реИ', 'рдУ': 'реЛ', 'рдФ': 'реМ'
    }

    # рез. 'рдЕ' рдЕрдВрдд (Inherent A) рдХреА рдЬрд╛рдВрдЪ - рдЙрджрд╛. 'рдЕрдГ' matches 'рд░рд╛рдордГ'
    if suffix.startswith('рдЕ'):
        core = suffix[1:]
        if not word.endswith(core): return False
        pos = len(word) - len(core) - 1
        if pos < 0: return False
        # рдпрджрд┐ рд╡рд┐рд╕рд░реНрдЧ/рдкреНрд░рддреНрдпрдп рд╕реЗ рдкрд╣рд▓реЗ рд╢реБрджреНрдз рд╡реНрдпрдВрдЬрди рд╣реИ, рддреЛ рд╡рд╣ 'рдЕ' рдЕрдВрдд рд╣реИ
        return '\u0915' <= word[pos] <= '\u0939'

    # реи. рд╕реНрд╡рд░реЛрдВ рдХреЛ рдорд╛рддреНрд░рд╛рдУрдВ рдореЗрдВ рдмрджрд▓рдХрд░ рдЬрд╛рдВрдЪрдирд╛
    for v, m in vowel_to_matra.items():
        if suffix.startswith(v):
            if word.endswith(m + suffix[1:]): return True

    # рей. рд╕рд╛рдорд╛рдиреНрдп рдЕрдВрдд (рд╡рд┐рд╕рд░реНрдЧ, рд╣рд▓рдиреНрдд рдЖрджрд┐)
    return word.endswith(suffix)


# --- рей. рдкрд░рд┐рд╖реНрдХреГрдд рдПрд╡рдВ Robust рдорд╛рд╕реНрдЯрд░ рд▓реЙрдЬрд┐рдХ ---
# рдпрд╣рд╛рдБ 'рд╕реНрд╡рд░' рдХреЛ рдЙрдирдХреА рдорд╛рддреНрд░рд╛рдУрдВ рдХреЗ рд░реВрдк рдореЗрдВ рдФрд░ рд╡реНрдпрдЮреНрдЬрдирд╛рдиреНрдд 'Signatures' рдХреЛ рд╢рд╛рдорд┐рд▓ рдХрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИ
LOGIC_RULES = {
    "рдкреНрд░рдердорд╛ рдПрдХрд╡рдЪрди": [
        "рдГ", "рдиреН", "рдореН", "рд╛", "реА", "реВ", "рдЛ",
        "рдХреН", "рдЯреН", "рдкреН", "рддреН"
    ],
    "рдкреНрд░рдердорд╛ рджреНрд╡рд┐рд╡рдЪрди": [
        "рдЖ", "рдИ", "рдФ", "рдП", "реМ", "реЗ", "реА"
    ],
    "рдкреНрд░рдердорд╛ рдмрд╣реБрд╡рдЪрди": [
        "рд╛рдГ", "рдпрдГ", "рд╡рдГ", "рдгрд┐", "рд╕рд┐",
        "рдЕрдГ", "рд╣рдГ", "рдзрдГ", "рд╢рдГ", "рддрдГ", "рдирдГ"
    ],
    "рджреНрд╡рд┐рддреАрдпрд╛ рдмрд╣реБрд╡рдЪрди": [
        "рдЖрдиреН", "рдИрдиреН", "реВрдиреН", "реДрдиреН", "рдГ",
        "рдИрдГ", "рдКрдГ", "рдЕрдГ", "рд╛рдГ"
    ],
    "рддреГрддреАрдпрд╛ рдПрдХрд╡рдЪрди": [
        "рдПрдг", "рдгрд╛", "рдирд╛", "рдпрд╛", "рддреНрд░рд╛", "рд╕рд╛", "рд╡рд╛", "рд╛",
        "рддрд╛", "рдзрд╛", "рднрд╛"
    ],
    "рдЪрддреБрд░реНрдереА рдПрдХрд╡рдЪрди": [
        "рдЖрдп", "рдпреЗ", "рд╡реЗ", "рддреНрд░реЗ", "рдпреИ", "рд╕реНрдореИ", "рднреНрдпрдореН",
        "рддреЗ", "рдиреЗ", "рд╕реЗ", "рдП"
    ],
    "рд╖рд╖реНрдареА рдПрдХрд╡рдЪрди": [
        "рд╕реНрдп", "рдЕрдГ", "рдУрдГ", "рдЖрдГ", "рдпрд╛рдГ", "рддреБрдГ", "рд╕рдГ",
        "рддрдГ", "рдирдГ", "рдЪрдГ", "рдЬрдГ"
    ],
    "рд╕рдкреНрддрдореА рдПрдХрд╡рдЪрди": [
        "рдП", "рдФ", "рд░рд┐", "рддрд┐", "рдирд┐", "рд╡рд┐", "рдпрд┐", "рдпрд╛рдореН", "рд╡рд╛рдореН",
        "рдЗ", "рд╖рд┐", "рдзрд┐"
    ]
}

VIBHAKTI_ORDER = {
    "рдкреНрд░рдердорд╛ рдПрдХрд╡рдЪрди": 1, "рдкреНрд░рдердорд╛ рджреНрд╡рд┐рд╡рдЪрди": 2, "рдкреНрд░рдердорд╛ рдмрд╣реБрд╡рдЪрди": 3,
    "рджреНрд╡рд┐рддреАрдпрд╛ рдмрд╣реБрд╡рдЪрди": 6, "рддреГрддреАрдпрд╛ рдПрдХрд╡рдЪрди": 7, "рдЪрддреБрд░реНрдереА рдПрдХрд╡рдЪрди": 10,
    "рд╖рд╖реНрдареА рдПрдХрд╡рдЪрди": 16, "рд╕рдкреНрддрдореА рдПрдХрд╡рдЪрди": 19
}


# --- рек. рдореБрдЦреНрдп рдПрдкреНрд▓реАрдХреЗрд╢рди рд▓реЙрдЬрд┐рдХ ---
def main():
    st.title("ЁЯФм Clinical Vibhakti Diagnostic Engine")
    st.caption("рд╡рд┐рднрдХреНрддрд┐ рдХреНрд░рдорд╛рдиреБрд╕рд╛рд░ рд╕рдВрддреБрд▓рд┐рдд рдкреНрд░рджрд░реНрд╢рди (Max 5 per category) | рдХреЗрд╡рд▓ рд╡реНрдпрд╛рдХрд░рдгрд┐рдХ рд╡рд┐рд╢реНрд▓реЗрд╖рдг")

    data = load_shabd_data()
    if not data:
        st.error("рдбреЗрдЯрд╛рдмреЗрд╕ (data/shabdroop.json) рдЕрдкреНрд░рд╛рдкреНрдд рд╣реИред")
        st.stop()

    # рд▓рдХреНрд╖рдгреЛрдВ рдХреА рдорд╛рд╕реНрдЯрд░ рд▓рд┐рд╕реНрдЯ (Unique Suffixes)
    all_symptoms = sorted(list(set([s for rules in LOGIC_RULES.values() for s in rules])))

    selected_symptom = st.sidebar.selectbox(
        "рд╡рд┐рд╢рд┐рд╖реНрдЯ рдкреНрд░рддреНрдпрдп рдЕрдВрдд рдЪреБрдиреЗрдВ:",
        ["--рд╕рднреА рджрд┐рдЦрд╛рдПрдВ--"] + all_symptoms
    )

    # рел. рд╕рдВрддреБрд▓рд┐рдд рдбрд╛рдпрдЧреНрдиреЛрд╕реНрдЯрд┐рдХ рдкреНрд░реЛрд╕реЗрд╕рд┐рдВрдЧ
    matches = []
    category_counter = Counter()

    # рд░реИрдВрдбрдо рд╕реИрдВрдкрд▓рд┐рдВрдЧ рдХреЗ рд▓рд┐рдП рдбреЗрдЯрд╛ рд╢рдлрд▓
    random.shuffle(data)

    for entry in data:
        raw_forms = entry.get("forms", "").split(";")
        if len(raw_forms) < 100: continue

        mapping = {
            "рдкреНрд░рдердорд╛ рдПрдХрд╡рдЪрди": raw_forms[0], "рдкреНрд░рдердорд╛ рджреНрд╡рд┐рд╡рдЪрди": raw_forms[1], "рдкреНрд░рдердорд╛ рдмрд╣реБрд╡рдЪрди": raw_forms[2],
            "рджреНрд╡рд┐рддреАрдпрд╛ рдмрд╣реБрд╡рдЪрди": raw_forms[5], "рддреГрддреАрдпрд╛ рдПрдХрд╡рдЪрди": raw_forms[6], "рдЪрддреБрд░реНрдереА рдПрдХрд╡рдЪрди": raw_forms[9],
            "рд╖рд╖реНрдареА рдПрдХрд╡рдЪрди": raw_forms[15], "рд╕рдкреНрддрдореА рдПрдХрд╡рдЪрди": raw_forms[18]
        }

        for vibhakti, roop in mapping.items():
            if category_counter[vibhakti] >= 5:
                continue

            patterns = LOGIC_RULES[vibhakti]
            for p in patterns:
                if sanskrit_match(roop, p):
                    # рдпрджрд┐ рдпреВрдЬрд░ рдиреЗ рдХреЛрдИ рд╕реНрдкреЗрд╕рд┐рдлрд┐рдХ рд▓рдХреНрд╖рдг рдЪреБрдирд╛ рд╣реИ
                    if selected_symptom == "--рд╕рднреА рджрд┐рдЦрд╛рдПрдВ--" or sanskrit_match(roop, selected_symptom):
                        matches.append({
                            "order": VIBHAKTI_ORDER[vibhakti],
                            "рд╢рдмреНрдж": entry.get("word"),
                            "рд╡рд┐рднрдХреНрддрд┐": vibhakti,
                            "рд░реВрдк": roop,
                            "рд▓рдХреНрд╖рдг": p
                        })
                        category_counter[vibhakti] += 1
                        break

    # рем. рдХреНрд░рдорд╛рдиреБрд╕рд╛рд░ рд╕реЙрд░реНрдЯрд┐рдВрдЧ рдПрд╡рдВ рдкреНрд░рджрд░реНрд╢рди
    if matches:
        sorted_examples = sorted(matches, key=lambda x: x['order'])
        df = pd.DataFrame(sorted_examples)

        # рдЕрд░реНрде рдХреЙрд▓рдо рд╣рдЯрд╛рдХрд░ рдХреЗрд╡рд▓ рд╢реБрджреНрдз рд╡реНрдпрд╛рдХрд░рдгрд┐рдХ рдбреЗрдЯрд╛
        st.table(df[["рд╢рдмреНрдж", "рд╡рд┐рднрдХреНрддрд┐", "рд░реВрдк", "рд▓рдХреНрд╖рдг"]])
        st.info(f"ЁЯТб рд╕рдВрддреБрд▓рд┐рдд рдкреНрд░рджрд░реНрд╢рди: рдкреНрд░рддреНрдпреЗрдХ рдЙрдкрд▓рдмреНрдз рд╢реНрд░реЗрдгреА рд╕реЗ рдЕрдзрд┐рдХрддрдо 5 рдЙрджрд╛рд╣рд░рдгред рдХреБрд▓ {len(matches)} рд░реВрдк рдкреНрд░рджрд░реНрд╢рд┐рдд рд╣реИрдВред")
    else:
        st.warning(f"рд▓рдХреНрд╖рдг '{selected_symptom}' рдХреЗ рд▓рд┐рдП рдХреЛрдИ рдореЗрд▓ рдирд╣реАрдВ рдорд┐рд▓рд╛ред")

    # рен. рд╡рд┐рдЬрд╝реБрдЕрд▓рд╛рдЗрдЬрд╝реЗрд╢рди
    st.divider()
    st.subheader("ЁЯзм рдкрдж-рдирд┐рд░реНрдорд╛рдг рдкреНрд░рдХреНрд░рд┐рдпрд╛ (Morphology)")


if __name__ == "__main__":
    main()