import streamlit as st
import json
import os
import random
import pandas as pd

# --- рез. рдкреЗрдЬ рд╕реЗрдЯрдЕрдк ---
st.set_page_config(page_title="Vibhakti Diagnostic Engine", layout="wide", page_icon="ЁЯФм")


@st.cache_data
def load_shabd_data():
    # рдбреЙрдХреНрдЯрд░ рд╕рд╛рд╣рдм рджреНрд╡рд╛рд░рд╛ рдирд┐рд░реНрджреЗрд╢рд┐рдд рдирдпрд╛ рдкрд╛рде
    file_path = os.path.join("data", "shabdroop.json")
    try:
        if not os.path.exists(file_path):
            return []
        with open(file_path, "r", encoding="utf-8") as file:
            return json.load(file)
    except:
        return []


# --- реи. Sanskrit-Aware Suffix Matcher (The Fix) ---
def sanskrit_match(word, suffix):
    """рд╕рдВрд╕реНрдХреГрдд рдХреЗ рдЕрджреГрд╢реНрдп 'рдЕ' рдФрд░ рдорд╛рддреНрд░рд╛рдУрдВ рдХреЛ рдкрд╣рдЪрд╛рдирдиреЗ рд╡рд╛рд▓рд╛ рд▓реЙрдЬрд┐рдХ"""
    if not suffix or suffix == "--рд╕рднреА рджрд┐рдЦрд╛рдПрдВ--": return True
    word = word.strip()

    # рез. рдкреВрд░реНрдг рд╕реНрд╡рд░ (рдЖ, рдИ, рдЙ...) рдХреЛ рдЙрдирдХреА рдорд╛рддреНрд░рд╛рдУрдВ (рд╛, реА, реБ...) рдореЗрдВ рдмрджрд▓рдирд╛
    vowel_to_matra = {
        'рдЖ': 'рд╛', 'рдЗ': 'рд┐', 'рдИ': 'реА', 'рдЙ': 'реБ', 'рдК': 'реВ',
        'рдЛ': 'реГ', 'рдП': 'реЗ', 'рдР': 'реИ', 'рдУ': 'реЛ', 'рдФ': 'реМ'
    }

    # реи. рдЕрджреГрд╢реНрдп 'рдЕ' (Inherent A) рдХрд╛ рд▓реЙрдЬрд┐рдХ: рдЙрджрд╛. 'рдЕрдГ' matches 'рд░рд╛рдордГ'
    if suffix.startswith('рдЕ'):
        core_suffix = suffix[1:]  # рдЙрджрд╛. 'рдГ'
        if not word.endswith(core_suffix): return False
        # рд╡рд┐рд╕рд░реНрдЧ рд╕реЗ рдареАрдХ рдкрд╣рд▓реЗ рд╡рд╛рд▓рд╛ рд╡рд░реНрдг рджреЗрдЦреЗрдВ
        pos = len(word) - len(core_suffix) - 1
        if pos < 0: return False
        char_before = word[pos]
        # рдпрджрд┐ рд╡рд╣ рд╡реНрдпрдВрдЬрди рд╣реИ рдФрд░ рдЙрд╕ рдкрд░ рдХреЛрдИ рдорд╛рддреНрд░рд╛ рдирд╣реАрдВ рд╣реИ, рддреЛ рд╡рд╣ 'рдЕ' рдЕрдВрдд рд╡рд╛рд▓рд╛ рд╣реИ
        return '\u0915' <= char_before <= '\u0939'

    # рей. рдЕрдиреНрдп рд╕реНрд╡рд░реЛрдВ рдХреЗ рд▓рд┐рдП рдорд╛рддреНрд░рд╛ рдЪреЗрдХ рдХрд░рдирд╛ (рдЙрджрд╛. 'рдЖрдГ' matches 'рд░рдорд╛рдпрд╛рдГ')
    for vowel, matra in vowel_to_matra.items():
        if suffix.startswith(vowel):
            m_suffix = matra + suffix[1:]
            if word.endswith(m_suffix): return True

    # рек. рд╕рд╛рдорд╛рдиреНрдп рдореИрдЪрд┐рдВрдЧ (рд╡рд┐рд╕рд░реНрдЧ, рд╣рд▓рдиреНрдд рдЖрджрд┐ рдХреЗ рд▓рд┐рдП)
    return word.endswith(suffix)


# --- рей. рдорд╛рд╕реНрдЯрд░ рд▓реЙрдЬрд┐рдХ рдПрд╡рдВ рдХреНрд░рдо ---
LOGIC_RULES = {
    "рдкреНрд░рдердорд╛ рдПрдХрд╡рдЪрди": ["рдГ", "рдиреН", "рдореН", "рд╕реНрд╡рд░"],
    "рдкреНрд░рдердорд╛ рджреНрд╡рд┐рд╡рдЪрди": ["рдЖ", "рдИ", "рдФ", "рдП"],
    "рдкреНрд░рдердорд╛ рдмрд╣реБрд╡рдЪрди": ["рд╛рдГ", "рдпрдГ", "рд╡рдГ", "рдгрд┐", "рд╕рд┐"],
    "рджреНрд╡рд┐рддреАрдпрд╛ рдмрд╣реБрд╡рдЪрди": ["рдЖрдиреН", "рдИрдиреН", "реВрдиреН", "реДрдиреН", "рдГ"],
    "рддреГрддреАрдпрд╛ рдПрдХрд╡рдЪрди": ["рдПрдг", "рдгрд╛", "рдирд╛", "рдпрд╛", "рддреНрд░рд╛", "рд╕рд╛", "рд╡рд╛", "рд╛"],
    "рдЪрддреБрд░реНрдереА рдПрдХрд╡рдЪрди": ["рдЖрдп", "рдпреЗ", "рд╡реЗ", "рддреНрд░реЗ", "рдпреИ", "рд╕реНрдореИ", "рднреНрдпрдореН"],
    "рд╖рд╖реНрдареА рдПрдХрд╡рдЪрди": ["рд╕реНрдп", "рдЕрдГ", "рдУрдГ", "рдЖрдГ", "рдпрд╛рдГ", "рддреБрдГ", "рд╕рдГ"],
    "рд╕рдкреНрддрдореА рдПрдХрд╡рдЪрди": ["рдП", "рдФ", "рд░рд┐", "рддрд┐", "рдирд┐", "рд╡рд┐", "рдпрд┐", "рдпрд╛рдореН", "рд╡рд╛рдореН"]
}

VIBHAKTI_ORDER = {
    "рдкреНрд░рдердорд╛ рдПрдХрд╡рдЪрди": 1, "рдкреНрд░рдердорд╛ рджреНрд╡рд┐рд╡рдЪрди": 2, "рдкреНрд░рдердорд╛ рдмрд╣реБрд╡рдЪрди": 3,
    "рджреНрд╡рд┐рддреАрдпрд╛ рдмрд╣реБрд╡рдЪрди": 6, "рддреГрддреАрдпрд╛ рдПрдХрд╡рдЪрди": 7, "рдЪрддреБрд░реНрдереА рдПрдХрд╡рдЪрди": 10,
    "рд╖рд╖реНрдареА рдПрдХрд╡рдЪрди": 16, "рд╕рдкреНрддрдореА рдПрдХрд╡рдЪрди": 19
}


def main():
    st.title("ЁЯФм Clinical Vibhakti Diagnostic Engine")
    st.caption("рд╕рдВрд╕реНрдХреГрдд рд╡реНрдпрд╛рдХрд░рдг рд╡рд┐рд╢реНрд▓реЗрд╖рдг | рдХреНрд░рдорд╛рдиреБрд╕рд╛рд░ рдкреНрд░рджрд░реНрд╢рди (1.1 тЖТ 7.1)")

    data = load_shabd_data()
    if not data:
        st.error("рдбреЗрдЯрд╛рдмреЗрд╕ (data/shabdroop.json) рдЕрдкреНрд░рд╛рдкреНрдд рд╣реИред")
        st.stop()

    # --- рек. рд╕рд╛рдЗрдбрдмрд╛рд░ рдлрд╝рд┐рд▓реНрдЯрд░ ---
    all_symptoms = []
    for symptoms in LOGIC_RULES.values():
        all_symptoms.extend(symptoms)

    selected_symptom = st.sidebar.selectbox(
        "рд╡рд┐рд╢рд┐рд╖реНрдЯ рдкреНрд░рддреНрдпрдп рдЕрдВрдд (Suffix) рдЪреБрдиреЗрдВ:",
        ["--рд╕рднреА рджрд┐рдЦрд╛рдПрдВ--"] + sorted(list(set(all_symptoms)))
    )

    # --- рел. рдбрд╛рдпрдЧреНрдиреЛрд╕реНрдЯрд┐рдХ рдкреНрд░реЛрд╕реЗрд╕рд┐рдВрдЧ ---
    matches = []
    for entry in data:
        raw_forms = entry.get("forms", "").split(";")
        if len(raw_forms) < 21: continue

        mapping = {
            "рдкреНрд░рдердорд╛ рдПрдХрд╡рдЪрди": raw_forms[0], "рдкреНрд░рдердорд╛ рджреНрд╡рд┐рд╡рдЪрди": raw_forms[1], "рдкреНрд░рдердорд╛ рдмрд╣реБрд╡рдЪрди": raw_forms[2],
            "рджреНрд╡рд┐рддреАрдпрд╛ рдмрд╣реБрд╡рдЪрди": raw_forms[5], "рддреГрддреАрдпрд╛ рдПрдХрд╡рдЪрди": raw_forms[6], "рдЪрддреБрд░реНрдереА рдПрдХрд╡рдЪрди": raw_forms[9],
            "рд╖рд╖реНрдареА рдПрдХрд╡рдЪрди": raw_forms[15], "рд╕рдкреНрддрдореА рдПрдХрд╡рдЪрди": raw_forms[18]
        }

        for vibhakti, roop in mapping.items():
            patterns = LOGIC_RULES[vibhakti]
            for p in patterns:
                # рдпрд╣рд╛рдБ 'Sanskrit-Aware' рдореИрдЪрд┐рдВрдЧ рдХрд╛ рдЙрдкрдпреЛрдЧ рд╣реЛ рд░рд╣рд╛ рд╣реИ
                if sanskrit_match(roop, p):
                    if selected_symptom == "--рд╕рднреА рджрд┐рдЦрд╛рдПрдВ--" or sanskrit_match(roop, selected_symptom):
                        matches.append({
                            "order": VIBHAKTI_ORDER[vibhakti],
                            "рд╢рдмреНрдж": entry.get("word"),
                            "рд╡рд┐рднрдХреНрддрд┐": vibhakti,
                            "рд░реВрдк": roop,
                            "рд▓рдХреНрд╖рдг": p
                        })

    # --- рем. рд░реИрдВрдбрдо реиреж рдПрд╡рдВ рдХреНрд░рдорд╛рдиреБрд╕рд╛рд░ рдкреНрд░рджрд░реНрд╢рди ---
    if matches:
        sample_size = min(20, len(matches))
        random_examples = random.sample(matches, sample_size)
        sorted_examples = sorted(random_examples, key=lambda x: x['order'])

        df = pd.DataFrame(sorted_examples)
        st.table(df[["рд╢рдмреНрдж", "рд╡рд┐рднрдХреНрддрд┐", "рд░реВрдк", "рд▓рдХреНрд╖рдг"]])
        st.info(f"ЁЯТб рдХреБрд▓ {len(matches)} рдкрд░рд┐рдгрд╛рдореЛрдВ рдореЗрдВ рд╕реЗ {sample_size} рдЙрджрд╛рд╣рд░рдг рдХреНрд░рдорд╛рдиреБрд╕рд╛рд░ рдкреНрд░рджрд░реНрд╢рд┐рдд рд╣реИрдВред")
    else:
        st.warning(f"рд▓рдХреНрд╖рдг '{selected_symptom}' рдХреЗ рд▓рд┐рдП рдХреЛрдИ рд╕рдЯреАрдХ рдореЗрд▓ рдирд╣реАрдВ рдорд┐рд▓рд╛ред")


if __name__ == "__main__":
    main()