import streamlit as st
import json
import os
import random
import pandas as pd
from collections import Counter

# --- рез. рдкреЗрдЬ рд╕реЗрдЯрдЕрдк ---
st.set_page_config(page_title="Vibhakti Diagnostic Engine", layout="wide", page_icon="ЁЯФм")

@st.cache_data
def load_shabd_data():
    file_path = os.path.join("data", "shabdroop.json")
    try:
        if not os.path.exists(file_path): return []
        with open(file_path, "r", encoding="utf-8") as file:
            return json.load(file)
    except:
        return []

# --- реи. Sanskrit-Aware Suffix Matcher ---
def sanskrit_match(word, suffix):
    if not suffix or suffix == "--рд╕рднреА рджрд┐рдЦрд╛рдПрдВ--": return True
    word = word.strip()
    vowel_to_matra = {
        'рдЖ': 'рд╛', 'рдЗ': 'рд┐', 'рдИ': 'реА', 'рдЙ': 'реБ', 'рдК': 'реВ',
        'рдЛ': 'реГ', 'рдП': 'реЗ', 'рдР': 'реИ', 'рдУ': 'реЛ', 'рдФ': 'реМ'
    }
    if suffix.startswith('рдЕ'):
        core_suffix = suffix[1:]
        if not word.endswith(core_suffix): return False
        pos = len(word) - len(core_suffix) - 1
        if pos < 0: return False
        return '\u0915' <= word[pos] <= '\u0939'
    for vowel, matra in vowel_to_matra.items():
        if suffix.startswith(vowel):
            if word.endswith(matra + suffix[1:]): return True
    return word.endswith(suffix)

# --- рей. рдорд╛рд╕реНрдЯрд░ рд▓реЙрдЬрд┐рдХ рдПрд╡рдВ рдХреНрд░рдо ---
LOGIC_RULES = {
    "рдкреНрд░рдердорд╛ рдПрдХрд╡рдЪрди": ["рдГ", "рдиреН", "рдореН", "рд╕реНрд╡рд░"],
    "рдкреНрд░рдердорд╛ рджреНрд╡рд┐рд╡рдЪрди": ["рдЖ", "рдИ", "рдФ", "рдП"],
    "рдкреНрд░рдердорд╛ рдмрд╣реБрд╡рдЪрди": ["рд╛рдГ", "рдпрдГ", "рд╡рдГ", "рдгрд┐", "рд╕рд┐"],
    "рджреНрд╡рд┐рддреАрдпрд╛ рдмрд╣реБрд╡рдЪрди": ["рдЖрдиреН", "рдИрдиреН", "реВрдиреН", "реДрдиреН", "рдГ"],
    "рддреГрддреАрдпрд╛ рдПрдХрд╡рдЪрди": ["рдПрдг", "рдгрд╛", "рдирд╛", "рдпрд╛", "рддреНрд░рд╛", "рд╕рд╛", "рд╡рд╛", "рд╛"],
    "рдЪрддреБрд░реНрдереА рдПрдХрд╡рдЪрди": ["рдЖрдп", "рдпреЗ", "рд╡реЗ", "рддреНрд░реЗ", "рдпреИ", "рд╕реНрдореИ", "рднреНрдпрдореН"],
    "рд╖рд╖реНрдареА рдПрдХрд╡рдЪрди": ["рд╕реНрдп", "рдЕрдГ", "рдУрдГ", "рдЖрдГ", "рдпрд╛рдГ", "рддреБрдГ", "рд╕рдГ"],
    "рд╕рдкреНрддрдореА рдПрдХрд╡рдЪрди": ["рдП", "рдФ", "рд░рд┐", "рддрд┐", "рдирд┐", "рд╡рд┐", "рдпрд┐", "рдпрд╛рдореН", "рд╡рд╛рдореН"]
}

VIBHAKTI_ORDER = {
    "рдкреНрд░рдердорд╛ рдПрдХрд╡рдЪрди": 1, "рдкреНрд░рдердорд╛ рджреНрд╡рд┐рд╡рдЪрди": 2, "рдкреНрд░рдердорд╛ рдмрд╣реБрд╡рдЪрди": 3,
    "рджреНрд╡рд┐рддреАрдпрд╛ рдмрд╣реБрд╡рдЪрди": 6, "рддреГрддреАрдпрд╛ рдПрдХрд╡рдЪрди": 7, "рдЪрддреБрд░реНрдереА рдПрдХрд╡рдЪрди": 10,
    "рд╖рд╖реНрдареА рдПрдХрд╡рдЪрди": 16, "рд╕рдкреНрддрдореА рдПрдХрд╡рдЪрди": 19
}

def main():
    st.title("ЁЯФм Clinical Vibhakti Diagnostic Engine")
    st.caption("рд╡рд┐рднрдХреНрддрд┐ рдХреНрд░рдорд╛рдиреБрд╕рд╛рд░ рд╕рдВрддреБрд▓рд┐рдд рдкреНрд░рджрд░реНрд╢рди (Max 5 per category)")

    data = load_shabd_data()
    if not data:
        st.error("рдбреЗрдЯрд╛рдмреЗрд╕ рдЕрдкреНрд░рд╛рдкреНрдд рд╣реИред")
        st.stop()

    all_symptoms = []
    for symptoms in LOGIC_RULES.values():
        all_symptoms.extend(symptoms)

    selected_symptom = st.sidebar.selectbox(
        "рд╡рд┐рд╢рд┐рд╖реНрдЯ рдкреНрд░рддреНрдпрдп рдЕрдВрдд рдЪреБрдиреЗрдВ:",
        ["--рд╕рднреА рджрд┐рдЦрд╛рдПрдВ--"] + sorted(list(set(all_symptoms)))
    )

    # --- рек. рд╕рдВрддреБрд▓рд┐рдд рдбрд╛рдпрдЧреНрдиреЛрд╕реНрдЯрд┐рдХ рдкреНрд░реЛрд╕реЗрд╕рд┐рдВрдЧ (The Smart Balancer) ---
    matches = []
    category_counter = Counter() # рдкреНрд░рддреНрдпреЗрдХ рд╡рд┐рднрдХреНрддрд┐ рдХреЗ рд▓рд┐рдП рдХрд╛рдЙрдВрдЯрд░

    # рдбреЗрдЯрд╛ рдХреЛ рдкрд╣рд▓реЗ рд╢рдлрд▓ (Shuffle) рдХрд░рдирд╛ рддрд╛рдХрд┐ рд░реИрдВрдбрдо рд╕реИрдВрдкрд▓рд┐рдВрдЧ рд╢реБрд░реВ рд╕реЗ рд╣реА рд╣реЛ
    random.shuffle(data)

    for entry in data:
        raw_forms = entry.get("forms", "").split(";")
        if len(raw_forms) < 21: continue

        mapping = {
            "рдкреНрд░рдердорд╛ рдПрдХрд╡рдЪрди": raw_forms[0], "рдкреНрд░рдердорд╛ рджреНрд╡рд┐рд╡рдЪрди": raw_forms[1], "рдкреНрд░рдердорд╛ рдмрд╣реБрд╡рдЪрди": raw_forms[2],
            "рджреНрд╡рд┐рддреАрдпрд╛ рдмрд╣реБрд╡рдЪрди": raw_forms[5], "рддреГрддреАрдпрд╛ рдПрдХрд╡рдЪрди": raw_forms[6], "рдЪрддреБрд░реНрдереА рдПрдХрд╡рдЪрди": raw_forms[9],
            "рд╖рд╖реНрдареА рдПрдХрд╡рдЪрди": raw_forms[15], "рд╕рдкреНрддрдореА рдПрдХрд╡рдЪрди": raw_forms[18]
        }

        for vibhakti, roop in mapping.items():
            # рдирд┐рдпрдо: рдпрджрд┐ рдЗрд╕ рд╡рд┐рднрдХреНрддрд┐ рдХреЗ рел рдЙрджрд╛рд╣рд░рдг рдкрд╣рд▓реЗ рд╣реА рдорд┐рд▓ рдЪреБрдХреЗ рд╣реИрдВ, рддреЛ рдЗрд╕реЗ рдЫреЛреЬ рджреЗрдВ
            if category_counter[vibhakti] >= 5:
                continue

            patterns = LOGIC_RULES[vibhakti]
            for p in patterns:
                if sanskrit_match(roop, p):
                    if selected_symptom == "--рд╕рднреА рджрд┐рдЦрд╛рдПрдВ--" or sanskrit_match(roop, selected_symptom):
                        matches.append({
                            "order": VIBHAKTI_ORDER[vibhakti],
                            "рд╢рдмреНрдж": entry.get("word"),
                            "рд╡рд┐рднрдХреНрддрд┐": vibhakti,
                            "рд░реВрдк": roop,
                            "рд▓рдХреНрд╖рдг": p
                        })
                        category_counter[vibhakti] += 1
                        break # рдПрдХ рд╣реА рд╢рдмреНрдж рдХреЗ рдПрдХ рд╣реА рд░реВрдк рдХреЗ рд▓рд┐рдП рдорд▓реНрдЯреАрдкрд▓ рд▓рдХреНрд╖рдг рди рдЬреЛреЬреЗрдВ

    # --- рел. рд╕реЙрд░реНрдЯрд┐рдВрдЧ рдПрд╡рдВ рдкреНрд░рджрд░реНрд╢рди ---
    if matches:
        # рдпрд╣рд╛рдБ random.sample рдХреА реЫрд░реВрд░рдд рдирд╣реАрдВ рдХреНрдпреЛрдВрдХрд┐ рдбреЗрдЯрд╛ рдкрд╣рд▓реЗ рд╣реА рд╢рдлрд▓ рд╣реЛ рдЪреБрдХрд╛ рд╣реИ рдФрд░ рел рдХреА рд▓рд┐рдорд┐рдЯ рд▓рдЧ рдЪреБрдХреА рд╣реИ
        sorted_examples = sorted(matches, key=lambda x: x['order'])

        df = pd.DataFrame(sorted_examples)
        st.table(df[["рд╢рдмреНрдж", "рд╡рд┐рднрдХреНрддрд┐", "рд░реВрдк", "рд▓рдХреНрд╖рдг"]])
        st.info(f"ЁЯТб рд╕рдВрддреБрд▓рд┐рдд рдкреНрд░рджрд░реНрд╢рди: рдкреНрд░рддреНрдпреЗрдХ рдЙрдкрд▓рдмреНрдз рд╢реНрд░реЗрдгреА рд╕реЗ рдЕрдзрд┐рдХрддрдо рел рдЙрджрд╛рд╣рд░рдг рд▓рд┐рдП рдЧрдП рд╣реИрдВред рдХреБрд▓ {len(matches)} рд░реВрдк рдкреНрд░рджрд░реНрд╢рд┐рдд рд╣реИрдВред")
    else:
        st.warning(f"рд▓рдХреНрд╖рдг '{selected_symptom}' рдХреЗ рд▓рд┐рдП рдХреЛрдИ рдореЗрд▓ рдирд╣реАрдВ рдорд┐рд▓рд╛ред")

if __name__ == "__main__":
    main()