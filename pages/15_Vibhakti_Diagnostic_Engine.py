import streamlit as st
import json
import os
import random
import pandas as pd

# --- рез. рдкреЗрдЬ рд╕реЗрдЯрдЕрдк ---
st.set_page_config(page_title="Vibhakti Diagnostic Engine", layout="wide", page_icon="ЁЯФм")


@st.cache_data
def load_shabd_data():
    file_path = os.path.join("data", "shabdroop.json")
    try:
        if not os.path.exists(file_path):
            st.error(f"рдлрд╝рд╛рдЗрд▓ рдирд╣реАрдВ рдорд┐рд▓реА: {file_path}")
            return []
        with open(file_path, "r", encoding="utf-8") as file:
            return json.load(file)
    except Exception as e:
        st.error(f"рдбреЗрдЯрд╛ рд▓реЛрдб рдХрд░рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐: {e}")
        return []


# --- реи. рдбреЙрдХреНрдЯрд░ рд╕рд╛рд╣рдм рдХрд╛ 'Master Logic' ---
LOGIC_RULES = {
    "рдкреНрд░рдердорд╛ рдПрдХрд╡рдЪрди": ["рдГ", "рдиреН", "рдореН", "рд╕реНрд╡рд░"],
    "рдкреНрд░рдердорд╛ рджреНрд╡рд┐рд╡рдЪрди": ["рдЖ", "рдИ", "рдФ", "рдП"],
    "рдкреНрд░рдердорд╛ рдмрд╣реБрд╡рдЪрди": ["рд╛рдГ", "рдпрдГ", "рд╡рдГ", "рдгрд┐", "рд╕рд┐"],
    "рджреНрд╡рд┐рддреАрдпрд╛ рдмрд╣реБрд╡рдЪрди": ["рдЖрдиреН", "рдИрдиреН", "реВрдиреН", "реДрдиреН", "рдГ"],
    "рддреГрддреАрдпрд╛ рдПрдХрд╡рдЪрди": ["рдПрдг", "рдгрд╛", "рдирд╛", "рдпрд╛", "рддреНрд░рд╛", "рд╕рд╛", "рд╡рд╛", "рд╛"],
    "рдЪрддреБрд░реНрдереА рдПрдХрд╡рдЪрди": ["рд╛рдп", "рдпреЗ", "рд╡реЗ", "рддреНрд░реЗ", "рдпреИ", "рд╕реНрдореИ", "рднреНрдпрдореН"],
    "рд╖рд╖реНрдареА рдПрдХрд╡рдЪрди": ["рд╕реНрдп", "рдЕрдГ", "рдУрдГ", "рдЖрдГ", "рдпрд╛рдГ", "рддреБрдГ", "рд╕рдГ"],
    "рд╕рдкреНрддрдореА рдПрдХрд╡рдЪрди": ["рдП", "рдФ", "рд░рд┐", "рддрд┐", "рдирд┐", "рд╡рд┐", "рдпрд┐", "рдпрд╛рдореН", "рд╡рд╛рдореН"]
}

# рд╡рд┐рднрдХреНрддрд┐ рдХрд╛ рд╢рд╛рд╕реНрддреНрд░реАрдп рдХреНрд░рдо (Sorting Order)
VIBHAKTI_ORDER = {
    "рдкреНрд░рдердорд╛ рдПрдХрд╡рдЪрди": 1, "рдкреНрд░рдердорд╛ рджреНрд╡рд┐рд╡рдЪрди": 2, "рдкреНрд░рдердорд╛ рдмрд╣реБрд╡рдЪрди": 3,
    "рджреНрд╡рд┐рддреАрдпрд╛ рдмрд╣реБрд╡рдЪрди": 6, "рддреГрддреАрдпрд╛ рдПрдХрд╡рдЪрди": 7, "рдЪрддреБрд░реНрдереА рдПрдХрд╡рдЪрди": 10,
    "рд╖рд╖реНрдареА рдПрдХрд╡рдЪрди": 16, "рд╕рдкреНрддрдореА рдПрдХрд╡рдЪрди": 19
}


def main():
    st.title("ЁЯФм Clinical Vibhakti Diagnostic Engine")
    st.caption("рд╡рд┐рднрдХреНрддрд┐ рдХреНрд░рдорд╛рдиреБрд╕рд╛рд░ (Chronological) рдкреНрд░рджрд░реНрд╢рди | data/shabdroop.json")

    data = load_shabd_data()
    if not data: st.stop()

    # --- рей. рдбрд╛рдпрдЧреНрдиреЛрд╕реНрдЯрд┐рдХ рдЗрдВрдЯрд░рдлреЗрд╕ ---
    st.sidebar.header("ЁЯФН рд▓рдХреНрд╖рдг (Symptoms)")
    all_symptoms = []
    for symptoms in LOGIC_RULES.values():
        all_symptoms.extend(symptoms)

    selected_symptom = st.sidebar.selectbox(
        "рд╡рд┐рд╢рд┐рд╖реНрдЯ рдкреНрд░рддреНрдпрдп рдЕрдВрдд (Suffix) рдЪреБрдиреЗрдВ:",
        ["--рд╕рднреА рджрд┐рдЦрд╛рдПрдВ--"] + sorted(list(set(all_symptoms)))
    )

    # --- рек. рдореИрдЪрд┐рдВрдЧ рдПрд╡рдВ рдХреНрд░рдорд╛рдиреБрд╕рд╛рд░ рд╕реЙрд░реНрдЯрд┐рдВрдЧ ---
    matches = []
    for entry in data:
        raw_forms = entry.get("forms", "").split(";")
        if len(raw_forms) < 21: continue

        # рдЖрдкрдХреЗ рджреНрд╡рд╛рд░рд╛ рджрд┐рдП рдЧрдП рдореБрдЦреНрдп рео рд╡рд┐рднрдХреНрддрд┐ рдмрд┐рдиреНрджреБ
        mapping = {
            "рдкреНрд░рдердорд╛ рдПрдХрд╡рдЪрди": raw_forms[0],
            "рдкреНрд░рдердорд╛ рджреНрд╡рд┐рд╡рдЪрди": raw_forms[1],
            "рдкреНрд░рдердорд╛ рдмрд╣реБрд╡рдЪрди": raw_forms[2],
            "рджреНрд╡рд┐рддреАрдпрд╛ рдмрд╣реБрд╡рдЪрди": raw_forms[5],
            "рддреГрддреАрдпрд╛ рдПрдХрд╡рдЪрди": raw_forms[6],
            "рдЪрддреБрд░реНрдереА рдПрдХрд╡рдЪрди": raw_forms[9],
            "рд╖рд╖реНрдареА рдПрдХрд╡рдЪрди": raw_forms[15],
            "рд╕рдкреНрддрдореА рдПрдХрд╡рдЪрди": raw_forms[18]
        }

        for vibhakti, roop in mapping.items():
            roop = roop.strip()
            patterns = LOGIC_RULES[vibhakti]

            for p in patterns:
                if roop.endswith(p):
                    if selected_symptom == "--рд╕рднреА рджрд┐рдЦрд╛рдПрдВ--" or roop.endswith(selected_symptom):
                        matches.append({
                            "order": VIBHAKTI_ORDER[vibhakti],  # рд╕реЙрд░реНрдЯрд┐рдВрдЧ рдХреЗ рд▓рд┐рдП
                            "рд╢рдмреНрдж": entry.get("word"),
                            "рд╡рд┐рднрдХреНрддрд┐": vibhakti,
                            "рд░реВрдк": roop,
                            "рд▓рдХреНрд╖рдг": p,
                            "рдЕрд░реНрде": entry.get("artha_hin")
                        })

    # --- рел. рдкреНрд░рджрд░реНрд╢рди (Random 20 + Chronological Sort) ---
    st.subheader(f"ЁЯОп рдХреНрд░рдорд╛рдиреБрд╕рд╛рд░ 'Pattern Match' рд╡рд┐рд╢реНрд▓реЗрд╖рдг ({selected_symptom})")

    if matches:
        # рез. рдкрд╣рд▓реЗ реиреж рд░реИрдВрдбрдо рдЙрджрд╛рд╣рд░рдг рдЪреБрдиреЗрдВ
        sample_size = min(20, len(matches))
        random_examples = random.sample(matches, sample_size)

        # реи. рдЕрдм рдЗрдиреНрд╣реЗрдВ рд╡рд┐рднрдХреНрддрд┐ рдХреНрд░рдо (order) рдХреЗ рдЖрдзрд╛рд░ рдкрд░ рд╕реЙрд░реНрдЯ рдХрд░реЗрдВ
        sorted_examples = sorted(random_examples, key=lambda x: x['order'])

        df = pd.DataFrame(sorted_examples)
        # рдХреЗрд╡рд▓ рдЖрд╡рд╢реНрдпрдХ рдХреЙрд▓рдо рджрд┐рдЦрд╛рдПрдВ
        st.table(df[["рд╢рдмреНрдж", "рд╡рд┐рднрдХреНрддрд┐", "рд░реВрдк", "рд▓рдХреНрд╖рдг", "рдЕрд░реНрде"]])

        st.info(
            "ЁЯТб рдпреЗ реиреж рдЙрджрд╛рд╣рд░рдг рд░реИрдВрдбрдо рдЪреБрдиреЗ рдЧрдП рд╣реИрдВ, рд▓реЗрдХрд┐рди рдиреАрдЪреЗ рджреА рдЧрдИ рддрд╛рд▓рд┐рдХрд╛ рдореЗрдВ рдЗрдиреНрд╣реЗрдВ рд╢рд╛рд╕реНрддреНрд░реАрдп рд╡рд┐рднрдХреНрддрд┐ рдХреНрд░рдо (1.1 тЖТ 7.1) рдореЗрдВ рд╡реНрдпрд╡рд╕реНрдерд┐рдд рдХрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред")
    else:
        st.warning("рдЗрд╕ рд▓рдХреНрд╖рдг рдХреЗ рд▓рд┐рдП рдХреЛрдИ рд╕рдЯреАрдХ рдореЗрд▓ рдирд╣реАрдВ рдорд┐рд▓рд╛ред")


if __name__ == "__main__":
    main()