"""
FILE: core/phonology.py
PAS-v2.0: 5.0 (Siddha)
PILLAR: Varṇodaya (Śikṣā)
STATUS: Logic preserved exactly as per User Specification.
"""

import re

# --- १. व्याकरणिक स्थिरांक (Shastric Constants) ---
VOWELS_MAP = {
    'ा': 'आ', 'ि': 'इ', 'ी': 'ई', 'ु': 'उ', 'ू': 'ऊ',
    'ृ': 'ऋ', 'ॄ': 'ॠ', 'ॢ': 'ऌ', 'ॣ': 'ॡ',
    'े': 'ए', 'ै': 'ऐ', 'ो': 'ओ', 'ौ': 'औ'
}
REVERSE_VOWELS_MAP = {v: k for k, v in VOWELS_MAP.items()}
INDEPENDENT_VOWELS = 'अआइईउऊऋॠऌॡएऐओऔ'


# --- २. वर्ण क्लास (The Siddha Varna Entity) ---
class Varna:
    def __init__(self, raw_unit):
        """
        [PAS-5.0] Logic: Encapsulates the units generated by sanskrit_varna_vichhed.
        """
        self.char = raw_unit
        # Sutra 1.1.1/1.1.2 identification
        self.is_vowel = any(v in raw_unit for v in INDEPENDENT_VOWELS) or '३' in raw_unit
        # Sutra 1.1.8 identification
        self.is_anunasika = 'ँ' in raw_unit

        # Shastric Data Slots (Required for Zone 1-8 logic)
        self.sthana = []  # आास्य (Ref: Paniniya Shiksha)
        self.prayatna = None  # प्रयत्न
        self.sanjnas = set()  # Labeling (e.g., Guna, Vriddhi, It)
        self.trace = []  # Clinical Audit Trail for UI

        self._set_shiksha_profile()

    def _set_shiksha_profile(self):
        """Assigns Sthana/Prayatna based on traditional Shiksha rules."""
        mapping = {
            "कण्ठ": "अआकखगघङहः", "तालु": "इईचछजझञयश",
            "मूर्धा": "ऋॠटठडढणरष", "दन्त": "ऌतथदधनलस",
            "ओष्ठ": "उऊपफबभम", "नासिका": "ञमङणनमँं",
            "कण्ठतालु": "एऐ", "कण्ठोष्ठ": "ओऔ", "दन्तोष्ठ": "व"
        }
        for s, chars in mapping.items():
            if any(c in self.char for c in chars):
                self.sthana.append(s)

        if self.is_vowel:
            self.prayatna = "विवृत"
        elif any(c in self.char for c in "शषसह"):
            self.prayatna = "ईषद्विवृत"
        elif any(c in self.char for c in "यवरल"):
            self.prayatna = "ईषत्स्पृष्ट"
        else:
            self.prayatna = "स्पृष्ट"

    def __repr__(self):
        return self.char


# --- ३. विच्छेद इंजन (User's Exact Logic) ---
def sanskrit_varna_vichhed(text, return_objects=True):
    """
    [AUTHORITY]: User Defined - EXACT LOGIC PRESERVED.
    [FUNCTION]: गाधृँ -> ['ग्', 'आ', 'ध्', 'ऋ', 'ँ']
    """
    if not text:
        return []

    # नियम 16: ॐ
    if text == "ॐ":
        res = ["अ", "उ", "म्"]
    else:
        # नियम 3, 12: विशिष्ट संयुक्ताक्षर और अवग्रह
        text = text.replace('क्ष', 'क्‌ष').replace('त्र', 'त्‌र').replace('ज्ञ', 'ज्‌ञ').replace('श्र', 'श्‌र').replace(
            'ऽ', 'अ')

        # नियम 6: पञ्चम वर्ण नियम
        text = re.sub(r'ं(?=[कखगघ])', 'ङ्', text)
        text = re.sub(r'ं(?=[चछजझ])', 'ञ्', text)
        text = re.sub(r'ं(?=[टठडढ])', 'ण्', text)
        text = re.sub(r'ं(?=[तथदध])', 'न्', text)
        text = re.sub(r'ं(?=[पफबभ])', 'म्', text)

        res = []
        i = 0
        while i < len(text):
            char = text[i]

            # 1. स्वतंत्र स्वर प्रबंधन
            if char in INDEPENDENT_VOWELS:
                current_unit = char
                if i + 1 < len(text) and text[i + 1] == '३':
                    current_unit += '३'
                    i += 1
                res.append(current_unit)

                while i + 1 < len(text) and text[i + 1] in 'ंःँ':
                    if text[i + 1] == 'ं' and (i + 2 == len(text) or text[i + 2] == ' '):
                        res.append('म्')
                    else:
                        res.append(text[i + 1])
                    i += 1

            # 2. व्यंजन प्रबंधन
            elif '\u0915' <= char <= '\u0939' or char == 'ळ':
                res.append(char + '्')
                found_vowel = False
                if i + 1 < len(text):
                    next_char = text[i + 1]
                    if next_char == '्':
                        i += 1
                        found_vowel = True
                    elif next_char in VOWELS_MAP:
                        res.append(VOWELS_MAP[next_char])
                        i += 1
                        found_vowel = True
                        while i + 1 < len(text) and text[i + 1] in 'ंःँ':
                            if text[i + 1] == 'ं' and (i + 2 == len(text) or text[i + 2] == ' '):
                                res.append('म्')
                            else:
                                res.append(text[i + 1])
                            i += 1
                    elif next_char in 'ंःँ':
                        res.append('अ')
                        found_vowel = True
                        if next_char == 'ं' and (i + 2 == len(text) or text[i + 2] == ' '):
                            res.append('म्')
                        else:
                            res.append(next_char)
                        i += 1
                    elif next_char == ' ':
                        res.append('अ')
                        found_vowel = True

                if not found_vowel:
                    res.append('अ')

            elif char in 'ᳲᳳ':
                res.append(char)
            i += 1

    if return_objects:
        return [Varna(s) for s in res]
    return " + ".join(res)

# --- ४. संयोग इंजन (Synthesis) ---
def sanskrit_varna_samyoga(varna_list):
    """
    [PAS-5.0] Reconstructs string from Varna objects.
    """
    if not varna_list: return ""
    text_list = [v.char if hasattr(v, 'char') else v for v in varna_list]
    res = ""
    for char in text_list:
        if not res: res = char; continue
        if res.endswith('्') and any(v in char for v in INDEPENDENT_VOWELS):
            matra = REVERSE_VOWELS_MAP.get(char[0], "") if char[0] != 'अ' else ""
            res = res[:-1] + matra
            if len(char) > 1: res += char[1:]
        else: res += char
    return res

# --- ४. Global Foundation Alias ---
ad = sanskrit_varna_vichhed

"""
FILE: core/phonology.py
PAS-v2.0: 5.0 (Siddha)
"""

def ad(text, return_objects=True):
    """
    [AUTHORITY]: User Defined - EXECUTING GLOBAL BIOPSY.
    This is the mandatory entry point for all Sanskrit strings in the app.
    """
    # We use your logic because it is the only one that allows
    # for precise It-Sanjna (1.3.x) and Savarna (1.1.9) mapping.
    return sanskrit_varna_vichhed(text, return_objects)
